from typing import Dict, Any, Optional, List
from core.exceptions import ResearchException
from core.models import Research, ResearchIteration
from core.types import ResearchStatus, ResearchRequest
from config.settings import RESEARCH_CONFIG
from services.llm.service import LLMService
from services.embedding.service import EmbeddingService
from services.quality.service import QualityControlService

"""
QualityControlService class provides methods to control and evaluate the quality of research content generated by the LLMService.
"""

class ResearchService:
    def __init__(self, config: Optional[Dict[str, Any]] = None):
        self.config = config or RESEARCH_CONFIG
        self.llm_service = LLMService()
        self.embedding_service = EmbeddingService()
        self.quality_service = QualityControlService()
        self._research_cache: Dict[str, Research] = {}

    async def conduct_research(self, request: ResearchRequest) -> Research:
        try:
            # Initialize research
            research = Research(
                query=request.query,
                status=ResearchStatus.IN_PROGRESS
            )
            self._research_cache[research.id] = research

            # Set iteration parameters
            max_iterations = request.max_iterations or self.config["max_iterations"]
            quality_threshold = request.quality_threshold or self.config["quality_threshold"]

            # Conduct iterative research
            current_result = None
            iterations: List[ResearchIteration] = []

            for i in range(max_iterations):
                # Generate research content
                context = request.context if i == 0 else current_result
                result = await self.llm_service.generate_research(
                    query=request.query,
                    context=context
                )

                # Evaluate quality
                metrics = await self.quality_service.evaluate_quality(result)
                quality_level = self.quality_service.determine_quality_level(metrics)

                # Create iteration record
                iteration = ResearchIteration(
                    research_id=research.id,
                    iteration_number=i + 1,
                    result=result,
                    confidence_score=metrics.overall_score,
                    quality_score=metrics.overall_score,
                    metadata={"quality_level": quality_level}
                )
                iterations.append(iteration)

                # Check if quality meets threshold
                if metrics.overall_score >= quality_threshold:
                    research.result = result
                    research.confidence_score = metrics.overall_score
                    research.quality_score = metrics.overall_score
                    research.status = ResearchStatus.COMPLETED
                    break

                # If not meeting threshold, get improvements
                current_result = await self.quality_service.suggest_improvements(
                    result, metrics
                )

            # If we exhausted iterations without meeting threshold
            if research.status != ResearchStatus.COMPLETED:
                # Use the best iteration
                best_iteration = max(iterations, key=lambda x: x.quality_score)
                research.result = best_iteration.result
                research.confidence_score = best_iteration.confidence_score
                research.quality_score = best_iteration.quality_score
                research.status = ResearchStatus.COMPLETED

            research.metadata["iterations"] = len(iterations)
            return research

        except Exception as e:
            if research:
                research.status = ResearchStatus.FAILED
                research.metadata["error"] = str(e)
            raise ResearchException(f"Error conducting research: {str(e)}")

    def get_research(self, research_id: str) -> Optional[Research]:
        """Retrieve research by ID from cache."""
        return self._research_cache.get(research_id)

    async def enhance_with_embeddings(self, research: Research) -> Research:
        """Enhance research results with relevant embedded content."""
        try:
            # Create embeddings for the research result
            embeddings = await self.embedding_service.create_embeddings(
                research.result,
                metadata={"research_id": research.id}
            )
            
            # Store embeddings in metadata for future use
            research.metadata["embeddings"] = [
                {"text": e.text, "vector": e.vector}
                for e in embeddings
            ]
            
            return research
        except Exception as e:
            raise ResearchException(f"Error enhancing research with embeddings: {str(e)}")
